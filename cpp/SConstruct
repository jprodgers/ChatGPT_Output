import os
import shutil
import sys

use_mingw = ARGUMENTS.get("use_mingw", "no") == "yes"

env = Environment(tools=["mingw"] if use_mingw else None)


def resolve_godot_cpp_path():
    # 1) explicit override via CLI
    cli_path = ARGUMENTS.get("godot_cpp_path")
    if cli_path:
        return cli_path

    # 2) environment variable
    env_path = os.environ.get("GODOT_CPP_PATH")
    if env_path:
        return env_path

    # 3) common local layouts
    local_candidates = [
        "godot-cpp",  # inside the cpp/ folder
        os.path.join("..", "godot-cpp"),  # sibling to cpp/ at repo root
    ]
    for candidate in local_candidates:
        if os.path.isdir(candidate):
            return candidate

    return "godot-cpp"


godot_cpp_path = resolve_godot_cpp_path()
platform = ARGUMENTS.get("platform", env["PLATFORM"] if "PLATFORM" in env else sys.platform)
target = ARGUMENTS.get("target", "template_debug")
bits = ARGUMENTS.get("bits", "64")

if platform.startswith("win"):
    if use_mingw:
        # MinGW builds expect `g++` on PATH; give a clearer error when it is missing.
        if not env.Detect("g++") and not shutil.which("g++"):
            print("MinGW g++ compiler not found. Install MinGW-w64 and ensure its bin/ folder is on PATH,\n"
                  "or run SCons from an MSYS2 MinGW shell so g++ is available.")
            Exit(1)
    else:
        # SCons defaults to MSVC on Windows. Give a clearer error when `cl.exe` is not on PATH
        # so users know to either run from a Developer Command Prompt or opt into MinGW.
        if not env.Detect("cl") and not shutil.which("cl"):
            print("Microsoft Visual C++ compiler (cl.exe) not found. Run scons from a Visual Studio\n"
                  "Developer Command Prompt or pass use_mingw=yes to build with MinGW.")
            Exit(1)

if not os.path.isdir(godot_cpp_path):
    print("godot-cpp checkout not found. Set GODOT_CPP_PATH or pass godot_cpp_path=<path>.\n"
          "Searched cpp/godot-cpp, ../godot-cpp, and GODOT_CPP_PATH by default.")
    Exit(1)

# Newer godot-cpp layouts put almost all class headers in generated output (gen/include/...).
# Require at least one core header that ships with the repo to confirm the checkout exists.
core_header = os.path.join(godot_cpp_path, "include", "godot_cpp", "core", "method_ptrcall.hpp")
if not os.path.isfile(core_header):
    print(
        "godot-cpp headers are missing. Ensure GODOT_CPP_PATH points to a cloned godot-cpp checkout "
        "(for example include/godot_cpp/core/method_ptrcall.hpp should exist).\n"
        "Clone the branch that matches your Godot version (for example --branch 4.2) and try again."
    )
    Exit(1)

# Support both legacy output (include/gen/...) and newer layout (gen/include/...).
generated_header_candidates = [
    os.path.join(godot_cpp_path, "include", "gen", "godot_cpp", "classes", "global_constants.hpp"),
    os.path.join(godot_cpp_path, "gen", "include", "godot_cpp", "classes", "global_constants.hpp"),
]

if not any(os.path.isfile(path) for path in generated_header_candidates):
    print(
        "godot-cpp generated headers are missing. Run scons inside your godot-cpp checkout first, for example:\n"
        "  scons platform=windows target=template_release bits=64 generate_bindings=yes -C godot-cpp\n"
        "Newer godot-cpp versions output headers under gen/include/...; older ones use include/gen/....\n"
        "Use the same platform/target/toolchain flags here and in your godot-cpp build."
    )
    Exit(1)

# Ensure the include paths cover both layouts.
include_paths = [
    os.path.join(godot_cpp_path, "include"),
    os.path.join(godot_cpp_path, "include", "gen"),
    os.path.join(godot_cpp_path, "gen", "include"),
]

headers_path = None
headers_override = os.environ.get("GODOT_HEADERS")
if headers_override and os.path.isdir(headers_override):
    headers_path = headers_override
else:
    for candidate in [
        os.path.join(godot_cpp_path, "godot-headers"),
        os.path.join(godot_cpp_path, "godot_headers"),
    ]:
        if os.path.isdir(candidate):
            headers_path = candidate
            break

if not headers_path:
    print(
        "godot-headers (GDExtension API headers) not found under godot-cpp. Make sure the godot-cpp checkout includes\n"
        "the bundled godot-headers folder or set GODOT_HEADERS to point at a godot-headers checkout."
    )
    Exit(1)

env.Append(CPPPATH=include_paths + [os.path.join(headers_path, "godot")])

# Adjust C++ standard flag per toolchain
if platform.startswith("win") and not use_mingw:
    env.Append(CXXFLAGS=["/std:c++17"])
else:
    env.Append(CPPFLAGS=["-std=c++17"])

common_cppflags = []
if not platform.startswith("win"):
    common_cppflags.append("-fPIC")

if common_cppflags:
    env.Append(CPPFLAGS=common_cppflags)
env.Append(LIBPATH=[os.path.join(godot_cpp_path, "bin")])
env.Append(LIBS=[f"godot-cpp.{platform}.{target}.{bits}"])

sources = Glob("src/*.cpp")

lib_prefix = "lib" if not platform.startswith("win") else ""
lib_ext = ".dll" if platform.startswith("win") else (".dylib" if platform == "darwin" else ".so")
suffix = ".debug" if "debug" in target else ""

target_name = f"../bin/{lib_prefix}native_automata{suffix}{lib_ext}"

env.SharedLibrary(target=target_name, source=sources)
